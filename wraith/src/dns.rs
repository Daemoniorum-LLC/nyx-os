//! DNS management

use anyhow::{Result, anyhow};
use std::collections::HashMap;
use std::net::IpAddr;
use std::path::Path;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tracing::{info, debug};

use crate::config::NetworkConfig;

/// DNS manager
pub struct DnsManager {
    servers: Vec<String>,
    search_domains: Vec<String>,
    cache: Option<DnsCache>,
}

/// DNS cache entry
#[derive(Debug, Clone)]
struct CacheEntry {
    addresses: Vec<IpAddr>,
    expires: Instant,
}

/// Simple DNS cache
pub struct DnsCache {
    entries: HashMap<String, CacheEntry>,
    max_size: usize,
}

impl DnsManager {
    pub fn new(config: &NetworkConfig) -> Result<Self> {
        let cache = if config.dns.cache_enabled {
            Some(DnsCache::new(config.dns.cache_size))
        } else {
            None
        };

        Ok(Self {
            servers: config.dns.servers.clone(),
            search_domains: config.dns.search.clone(),
            cache,
        })
    }

    /// Set DNS servers
    pub fn set_servers(&mut self, servers: &[String]) -> Result<()> {
        self.servers = servers.to_vec();
        self.write_resolv_conf()?;
        info!("DNS servers updated: {:?}", self.servers);
        Ok(())
    }

    /// Add search domain
    pub fn add_search_domain(&mut self, domain: &str) -> Result<()> {
        if !self.search_domains.contains(&domain.to_string()) {
            self.search_domains.push(domain.to_string());
            self.write_resolv_conf()?;
        }
        Ok(())
    }

    /// Remove search domain
    pub fn remove_search_domain(&mut self, domain: &str) -> Result<()> {
        self.search_domains.retain(|d| d != domain);
        self.write_resolv_conf()?;
        Ok(())
    }

    /// Write /etc/resolv.conf
    fn write_resolv_conf(&self) -> Result<()> {
        let mut content = String::new();

        content.push_str("# Generated by Wraith network manager\n");

        if !self.search_domains.is_empty() {
            content.push_str(&format!("search {}\n", self.search_domains.join(" ")));
        }

        for server in &self.servers {
            content.push_str(&format!("nameserver {}\n", server));
        }

        // Write atomically
        let tmp_path = "/etc/resolv.conf.tmp";
        std::fs::write(tmp_path, &content)?;
        std::fs::rename(tmp_path, "/etc/resolv.conf")?;

        Ok(())
    }

    /// Resolve hostname
    pub fn resolve(&mut self, hostname: &str) -> Result<Vec<IpAddr>> {
        // Check cache first
        if let Some(ref mut cache) = self.cache {
            if let Some(addrs) = cache.get(hostname) {
                debug!("DNS cache hit: {}", hostname);
                return Ok(addrs);
            }
        }

        // Perform lookup
        let addrs = dns_lookup::lookup_host(hostname)?;

        // Cache result
        if let Some(ref mut cache) = self.cache {
            cache.insert(hostname, addrs.clone(), Duration::from_secs(300));
        }

        Ok(addrs)
    }

    /// Get current DNS servers
    pub fn get_servers(&self) -> &[String] {
        &self.servers
    }

    /// Clear DNS cache
    pub fn clear_cache(&mut self) {
        if let Some(ref mut cache) = self.cache {
            cache.clear();
        }
    }
}

impl DnsCache {
    pub fn new(max_size: usize) -> Self {
        Self {
            entries: HashMap::new(),
            max_size,
        }
    }

    pub fn get(&self, hostname: &str) -> Option<Vec<IpAddr>> {
        self.entries.get(hostname)
            .filter(|entry| entry.expires > Instant::now())
            .map(|entry| entry.addresses.clone())
    }

    pub fn insert(&mut self, hostname: &str, addresses: Vec<IpAddr>, ttl: Duration) {
        // Evict oldest if full
        if self.entries.len() >= self.max_size {
            self.evict_oldest();
        }

        self.entries.insert(hostname.to_string(), CacheEntry {
            addresses,
            expires: Instant::now() + ttl,
        });
    }

    pub fn clear(&mut self) {
        self.entries.clear();
    }

    fn evict_oldest(&mut self) {
        if let Some((oldest_key, _)) = self.entries.iter()
            .min_by_key(|(_, v)| v.expires)
            .map(|(k, v)| (k.clone(), v.clone()))
        {
            self.entries.remove(&oldest_key);
        }
    }
}
